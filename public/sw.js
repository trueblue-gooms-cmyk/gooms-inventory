// Service Worker para Gooms Inventory PWA
// Compatible con Lovable + Supabase - Modo offline inteligente

const CACHE_NAME = 'gooms-inventory-v1.0.0';
const OFFLINE_URL = '/offline.html';

// Recursos cr√≠ticos que SIEMPRE deben estar en cache
const CORE_ASSETS = [
  '/',
  '/index.html',
  '/offline.html',
  '/src/main.tsx',
  '/src/index.css'
];

// Patrones de URLs que pueden ser cacheadas
const CACHEABLE_PATTERNS = [
  /^\/assets\//,           // Assets est√°ticos de Vite
  /^\/src\//,              // C√≥digo fuente
  /\.(?:js|css|png|jpg|jpeg|svg|ico|woff2?)$/  // Archivos est√°ticos
];

// URLs que NO deben ser cacheadas (din√°micas/sensibles)
const SKIP_CACHE_PATTERNS = [
  /\/api\//,               // APIs din√°micas
  /supabase\.co/,          // Supabase en tiempo real
  /\/auth/,                // Autenticaci√≥n
  /\/notifications/        // Notificaciones tiempo real
];

// üöÄ INSTALACI√ìN DEL SERVICE WORKER
self.addEventListener('install', (event) => {
  console.log('üîß Service Worker: Instalando...');
  
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        console.log('üì¶ Cache abierto:', CACHE_NAME);
        // Pre-cachear recursos cr√≠ticos
        return cache.addAll(CORE_ASSETS.map(url => new Request(url, { cache: 'reload' })));
      })
      .then(() => {
        console.log('‚úÖ Recursos cr√≠ticos cacheados');
        // Forzar activaci√≥n inmediata
        return self.skipWaiting();
      })
      .catch((error) => {
        console.error('‚ùå Error en instalaci√≥n SW:', error);
      })
  );
});

// ‚ö° ACTIVACI√ìN DEL SERVICE WORKER
self.addEventListener('activate', (event) => {
  console.log('üöÄ Service Worker: Activando...');
  
  event.waitUntil(
    caches.keys()
      .then((cacheNames) => {
        // Limpiar caches antiguos
        return Promise.all(
          cacheNames.map((cacheName) => {
            if (cacheName !== CACHE_NAME) {
              console.log('üóëÔ∏è Eliminando cache antiguo:', cacheName);
              return caches.delete(cacheName);
            }
          })
        );
      })
      .then(() => {
        // Tomar control inmediato de todas las p√°ginas
        return self.clients.claim();
      })
      .then(() => {
        console.log('‚úÖ Service Worker activado y listo');
      })
  );
});

// üì° ESTRATEGIA DE FETCH - CACHE FIRST PARA ASSETS, NETWORK FIRST PARA DATOS
self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);
  
  // Ignorar requests que no deben ser cacheados
  if (SKIP_CACHE_PATTERNS.some(pattern => pattern.test(url.href))) {
    return; // Dejar que el navegador maneje normalmente
  }

  // Solo manejar requests GET
  if (event.request.method !== 'GET') {
    return;
  }

  event.respondWith(handleFetch(event.request));
});

// üîÑ L√ìGICA PRINCIPAL DE FETCH
async function handleFetch(request) {
  const url = new URL(request.url);
  
  try {
    // 1Ô∏è‚É£ STRATEGY: Cache First para assets est√°ticos
    if (CACHEABLE_PATTERNS.some(pattern => pattern.test(url.pathname))) {
      return await cacheFirstStrategy(request);
    }
    
    // 2Ô∏è‚É£ STRATEGY: Network First para datos din√°micos
    if (url.pathname.startsWith('/api/') || url.pathname.includes('supabase')) {
      return await networkFirstStrategy(request);
    }
    
    // 3Ô∏è‚É£ STRATEGY: Stale While Revalidate para p√°ginas
    return await staleWhileRevalidateStrategy(request);
    
  } catch (error) {
    console.error('‚ùå Error en fetch:', error);
    return await fallbackResponse(request);
  }
}

// üì¶ CACHE FIRST - Para assets que no cambian frecuentemente
async function cacheFirstStrategy(request) {
  const cachedResponse = await caches.match(request);
  
  if (cachedResponse) {
    return cachedResponse;
  }
  
  try {
    const networkResponse = await fetch(request);
    
    if (networkResponse.ok) {
      const cache = await caches.open(CACHE_NAME);
      await cache.put(request, networkResponse.clone());
    }
    
    return networkResponse;
  } catch (error) {
    throw error;
  }
}

// üåê NETWORK FIRST - Para datos en tiempo real
async function networkFirstStrategy(request) {
  try {
    const networkResponse = await fetch(request);
    
    // Solo cachear respuestas exitosas de datos GET
    if (networkResponse.ok && request.method === 'GET') {
      const cache = await caches.open(CACHE_NAME);
      await cache.put(request, networkResponse.clone());
    }
    
    return networkResponse;
  } catch (error) {
    // Si falla la red, intentar servir desde cache
    const cachedResponse = await caches.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }
    throw error;
  }
}

// üîÑ STALE WHILE REVALIDATE - Para p√°ginas que pueden mostrar contenido anterior
async function staleWhileRevalidateStrategy(request) {
  const cachedResponse = await caches.match(request);
  
  // Actualizar cache en background
  const fetchPromise = fetch(request).then(async (networkResponse) => {
    if (networkResponse.ok) {
      const cache = await caches.open(CACHE_NAME);
      await cache.put(request, networkResponse.clone());
    }
    return networkResponse;
  });
  
  // Retornar cache inmediatamente si existe, sino esperar la red
  return cachedResponse || await fetchPromise;
}

// üö® FALLBACK - Cuando todo falla
async function fallbackResponse(request) {
  const url = new URL(request.url);
  
  // Para navegaci√≥n, mostrar p√°gina offline
  if (request.mode === 'navigate') {
    const offlineResponse = await caches.match(OFFLINE_URL);
    return offlineResponse || new Response(
      `
      <!DOCTYPE html>
      <html>
        <head>
          <title>Sin conexi√≥n - Gooms Inventory</title>
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <style>
            body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }
            .offline { color: #666; }
          </style>
        </head>
        <body>
          <div class="offline">
            <h1>üì± Gooms Inventory</h1>
            <h2>Sin conexi√≥n a internet</h2>
            <p>Algunas funciones pueden no estar disponibles.</p>
            <button onclick="window.location.reload()">Reintentar</button>
          </div>
        </body>
      </html>
      `,
      {
        headers: { 'Content-Type': 'text/html' }
      }
    );
  }
  
  // Para otros recursos, retornar error gen√©rico
  return new Response(
    JSON.stringify({ 
      error: 'Sin conexi√≥n', 
      offline: true,
      message: 'Este contenido no est√° disponible offline'
    }),
    {
      status: 503,
      headers: { 'Content-Type': 'application/json' }
    }
  );
}

// üîÑ SINCRONIZACI√ìN EN BACKGROUND
self.addEventListener('sync', (event) => {
  console.log('üîÑ Background Sync:', event.tag);
  
  if (event.tag === 'inventory-sync') {
    event.waitUntil(syncInventoryData());
  }
  
  if (event.tag === 'notifications-sync') {
    event.waitUntil(syncNotifications());
  }
});

// üìä SINCRONIZAR DATOS DE INVENTARIO
async function syncInventoryData() {
  try {
    console.log('üìä Sincronizando datos de inventario...');
    
    // Obtener acciones pendientes del IndexedDB
    const db = await openOfflineDB();
    const transaction = db.transaction(['pending_actions'], 'readonly');
    const store = transaction.objectStore('pending_actions');
    const pendingActions = await getAllFromStore(store);
    
    console.log(`üìä Sincronizando ${pendingActions.length} acciones pendientes`);
    
    for (const action of pendingActions) {
      try {
        // Ejecutar acci√≥n contra la API
        const success = await executeActionSync(action);
        
        if (success) {
          // Remover acci√≥n exitosa
          await removeActionFromDB(db, action.id);
          console.log(`‚úÖ Acci√≥n ${action.type} sincronizada`);
        }
      } catch (error) {
        console.error(`‚ùå Error sincronizando acci√≥n ${action.type}:`, error);
      }
    }
    
    // Notificar al cliente que la sincronizaci√≥n termin√≥
    const clients = await self.clients.matchAll();
    clients.forEach(client => {
      client.postMessage({
        type: 'SYNC_COMPLETE',
        timestamp: Date.now()
      });
    });
    
  } catch (error) {
    console.error('‚ùå Error en sincronizaci√≥n background:', error);
  }
}

// üîî SINCRONIZAR NOTIFICACIONES
async function syncNotifications() {
  try {
    console.log('üîî Sincronizando notificaciones...');
    // L√≥gica de sincronizaci√≥n de notificaciones
  } catch (error) {
    console.error('‚ùå Error sincronizando notificaciones:', error);
  }
}

// üì± PUSH NOTIFICATIONS
self.addEventListener('push', (event) => {
  if (!event.data) return;
  
  const data = event.data.json();
  
  const options = {
    body: data.body || 'Nueva notificaci√≥n de Gooms Inventory',
    icon: '/icons/icon-192x192.png',
    badge: '/icons/icon-72x72.png',
    data: data.data || {},
    tag: data.tag || 'default',
    requireInteraction: data.requireInteraction || false,
    actions: data.actions || [
      {
        action: 'open',
        title: 'Abrir App',
        icon: '/icons/icon-192x192.png'
      },
      {
        action: 'dismiss',
        title: 'Descartar'
      }
    ],
    timestamp: Date.now()
  };
  
  event.waitUntil(
    self.registration.showNotification(data.title || 'Gooms Inventory', options)
  );
});

// üñ±Ô∏è CLICKS EN NOTIFICACIONES
self.addEventListener('notificationclick', (event) => {
  const notification = event.notification;
  const action = event.action;
  const data = notification.data || {};
  
  console.log('üñ±Ô∏è Notificaci√≥n clickeada:', { action, data });
  
  notification.close();
  
  // Manejar acciones espec√≠ficas
  let urlToOpen = '/';
  
  if (action === 'open' || !action) {
    if (data.type === 'low_stock') {
      urlToOpen = '/inventory';
    } else if (data.type === 'expiry_alert') {
      urlToOpen = '/inventory?tab=expiry';
    } else if (data.type === 'reception_pending') {
      urlToOpen = '/reception';
    } else if (data.url) {
      urlToOpen = data.url;
    }
    
    // Abrir o enfocar la app
    event.waitUntil(
      clients.matchAll({ type: 'window', includeUncontrolled: true })
        .then((clientList) => {
          // Buscar ventana existente con la URL objetivo
          for (const client of clientList) {
            if (client.url.includes(urlToOpen.split('?')[0]) && 'focus' in client) {
              return client.focus();
            }
          }
          
          // Si no hay ventana existente, abrir nueva
          if (clients.openWindow) {
            return clients.openWindow(urlToOpen);
          }
        })
    );
  } else if (action === 'dismiss') {
    // Notificar al cliente del cierre
    event.waitUntil(
      clients.matchAll().then((clientList) => {
        clientList.forEach(client => {
          client.postMessage({
            type: 'NOTIFICATION_CLOSE',
            payload: data
          });
        });
      })
    );
  }
  
  // Notificar al cliente del click
  event.waitUntil(
    clients.matchAll().then((clientList) => {
      clientList.forEach(client => {
        client.postMessage({
          type: 'NOTIFICATION_CLICK',
          payload: { action, data }
        });
      });
    })
  );
});

// ‚ùå CIERRE DE NOTIFICACIONES
self.addEventListener('notificationclose', (event) => {
  const notification = event.notification;
  const data = notification.data || {};
  
  console.log('‚ùå Notificaci√≥n cerrada:', data);
  
  // Notificar al cliente del cierre
  event.waitUntil(
    clients.matchAll().then((clientList) => {
      clientList.forEach(client => {
        client.postMessage({
          type: 'NOTIFICATION_CLOSE',
          payload: data
        });
      });
    })
  );
});

// üîó HELPER FUNCTIONS para IndexedDB
async function openOfflineDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('gooms-inventory-offline', 1);
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

async function getAllFromStore(store) {
  return new Promise((resolve) => {
    const request = store.getAll();
    request.onsuccess = () => resolve(request.result.filter(action => action.status === 'pending'));
    request.onerror = () => resolve([]);
  });
}

async function removeActionFromDB(db, actionId) {
  const transaction = db.transaction(['pending_actions'], 'readwrite');
  const store = transaction.objectStore('pending_actions');
  await store.delete(actionId);
}

async function executeActionSync(action) {
  // En un entorno real, esto har√≠a llamadas a Supabase
  // Por ahora simular √©xito para mantener compatibilidad
  console.log(`üîÑ Ejecutando ${action.type} con datos:`, action.data);
  
  // Simular tiempo de procesamiento
  await new Promise(resolve => setTimeout(resolve, 100));
  
  return true; // Simular √©xito
}

// üìù LOG DE EVENTOS PARA DEBUGGING
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
  
  if (event.data && event.data.type === 'GET_VERSION') {
    event.ports[0].postMessage({ version: CACHE_NAME });
  }
});

console.log('üöÄ Service Worker registrado correctamente - Gooms Inventory PWA');